# CD Pipeline - Manual deployment to production
name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version/SHA to deploy'
        required: true
        default: 'main'
      services:
        description: 'Services to deploy (comma-separated: api,scraper,mcp or all)'
        required: true
        default: 'all'
      skip_migrations:
        description: 'Skip database migrations'
        type: boolean
        default: false
      deployment_strategy:
        description: 'Deployment strategy'
        type: choice
        options:
        - rolling
        - blue-green
        default: rolling

env:
  GO_VERSION: '1.21'

jobs:
  # Pre-deployment validation
  pre-deployment-validation:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    environment: production
    
    outputs:
      services_to_deploy: ${{ steps.parse-services.outputs.services }}
      deployment_sha: ${{ steps.validate-version.outputs.sha }}
    
    steps:
    - uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.version }}
    
    - name: Validate version/SHA
      id: validate-version
      run: |
        if [[ "${{ github.event.inputs.version }}" == "main" ]]; then
          SHA=$(git rev-parse HEAD)
        else
          SHA="${{ github.event.inputs.version }}"
        fi
        
        # Validate SHA exists
        if ! git cat-file -e ${SHA}^{commit}; then
          echo "âŒ Invalid SHA: ${SHA}"
          exit 1
        fi
        
        echo "sha=${SHA}" >> $GITHUB_OUTPUT
        echo "âœ… Validated SHA: ${SHA}"
    
    - name: Parse services to deploy
      id: parse-services
      run: |
        if [[ "${{ github.event.inputs.services }}" == "all" ]]; then
          SERVICES="api,scraper,mcp"
        else
          SERVICES="${{ github.event.inputs.services }}"
        fi
        
        echo "services=${SERVICES}" >> $GITHUB_OUTPUT
        echo "ðŸ“¦ Services to deploy: ${SERVICES}"
    
    - name: Verify staging deployment
      run: |
        # Ensure this SHA was deployed to staging first
        STAGING_SHA=$(curl -s ${{ secrets.STAGING_URL }}/health | jq -r '.build_info.git_commit // "unknown"')
        
        if [[ "${STAGING_SHA}" != "${{ steps.validate-version.outputs.sha }}" ]]; then
          echo "âš ï¸  WARNING: SHA ${{ steps.validate-version.outputs.sha }} was not deployed to staging"
          echo "Current staging SHA: ${STAGING_SHA}"
          echo "Proceeding with manual override..."
        else
          echo "âœ… SHA verified in staging deployment"
        fi

  # Production backup before deployment
  production-backup:
    name: Production Backup
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    environment: production
    
    steps:
    - name: Create production backup
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USER }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          cd /opt/proteinprices
          
          # Create comprehensive backup
          BACKUP_NAME="prod-backup-$(date +%Y%m%d_%H%M%S)-${{ needs.pre-deployment-validation.outputs.deployment_sha }}"
          
          # Database backup
          docker-compose -f docker-compose.prod.yml exec -T postgres pg_dump -U proteinprices proteinprices | gzip > /opt/backups/${BACKUP_NAME}-db.sql.gz
          
          # Application state backup
          docker images --format "table {{.Repository}}:{{.Tag}}" | grep proteinprices > /opt/backups/${BACKUP_NAME}-images.txt
          
          # Configuration backup
          cp -r deployments/ /opt/backups/${BACKUP_NAME}-config/
          
          echo "backup_name=${BACKUP_NAME}" > /tmp/backup_info.txt
          echo "âœ… Production backup created: ${BACKUP_NAME}"

  # Deploy services with chosen strategy
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, production-backup]
    environment: production
    
    strategy:
      matrix:
        service: ${{ fromJSON(format('["{0}"]', join(split(needs.pre-deployment-validation.outputs.services_to_deploy, ','), '","'))) }}
      max-parallel: 1  # Deploy one service at a time
    
    steps:
    - uses: actions/checkout@v4
      with:
        ref: ${{ needs.pre-deployment-validation.outputs.deployment_sha }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build ${{ matrix.service }} production image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./deployments/docker/Dockerfile.${{ matrix.service }}
        target: production
        push: false
        tags: proteinprices-${{ matrix.service }}:prod-${{ needs.pre-deployment-validation.outputs.deployment_sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Save ${{ matrix.service }} image
      run: |
        docker save proteinprices-${{ matrix.service }}:prod-${{ needs.pre-deployment-validation.outputs.deployment_sha }} | gzip > ${{ matrix.service }}-prod.tar.gz

    - name: Copy image to production server
      uses: appleboy/scp-action@v0.1.4
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USER }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        source: "${{ matrix.service }}-prod.tar.gz"
        target: "/tmp/"

    - name: Deploy ${{ matrix.service }} with ${{ github.event.inputs.deployment_strategy }} strategy
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USER }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          cd /opt/proteinprices
          
          # Load new image
          docker load < /tmp/${{ matrix.service }}-prod.tar.gz
          
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "blue-green" ]]; then
            echo "ðŸ”„ Executing blue-green deployment for ${{ matrix.service }}"
            ./scripts/blue-green-deploy.sh ${{ matrix.service }} prod-${{ needs.pre-deployment-validation.outputs.deployment_sha }}
          else
            echo "ðŸ”„ Executing rolling deployment for ${{ matrix.service }}"
            
            # Tag image for deployment
            docker tag proteinprices-${{ matrix.service }}:prod-${{ needs.pre-deployment-validation.outputs.deployment_sha }} proteinprices-${{ matrix.service }}:latest
            
            # Rolling update
            docker-compose -f docker-compose.prod.yml up -d ${{ matrix.service }}
            
            # Wait and health check
            sleep 45
            
            # Enhanced health check
            for i in {1..6}; do
              if curl -f http://localhost:8080/health; then
                echo "âœ… Health check passed (attempt $i)"
                break
              fi
              
              if [[ $i -eq 6 ]]; then
                echo "âŒ Health check failed after 6 attempts, initiating rollback"
                make rollback-${{ matrix.service }}
                exit 1
              fi
              
              echo "â³ Health check failed, retrying in 10s (attempt $i/6)"
              sleep 10
            done
          fi
          
          echo "âœ… ${{ matrix.service }} deployed successfully to production"

  # Database migrations (if not skipped)
  migrate-production:
    name: Database Migration (Production)
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deploy-production]
    environment: production
    if: ${{ github.event.inputs.skip_migrations != 'true' }}
    
    steps:
    - name: Run production database migrations
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USER }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          cd /opt/proteinprices
          
          # Check migration status
          MIGRATION_STATUS=$(docker-compose -f docker-compose.prod.yml exec -T api /app/migrate status)
          
          if echo "$MIGRATION_STATUS" | grep -q "dirty\|pending"; then
            echo "ðŸ”„ Running database migrations (expand-migrate-contract pattern)..."
            
            # Additional pre-migration backup
            docker-compose -f docker-compose.prod.yml exec -T postgres pg_dump -U proteinprices proteinprices | gzip > /opt/backups/prod-pre-migration-$(date +%Y%m%d_%H%M%S).sql.gz
            
            # Run migrations with rollback capability
            if ! docker-compose -f docker-compose.prod.yml exec -T api /app/migrate up; then
              echo "âŒ Migration failed, check database state"
              docker-compose -f docker-compose.prod.yml exec -T api /app/migrate status
              exit 1
            fi
            
            echo "âœ… Database migrations completed successfully"
          else
            echo "â„¹ï¸  No pending migrations"
          fi

  # Production smoke tests
  production-smoke-tests:
    name: Production Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-production, migrate-production]
    if: always() && (needs.deploy-production.result == 'success')
    
    steps:
    - uses: actions/checkout@v4
      with:
        ref: ${{ needs.pre-deployment-validation.outputs.deployment_sha }}
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Run comprehensive production smoke tests
      run: |
        go test -v -tags=smoke,production ./tests/smoke/...
      env:
        TEST_BASE_URL: ${{ secrets.PRODUCTION_URL }}
        TEST_TIMEOUT: 30s

    - name: Validate critical production endpoints
      run: |
        # Core API health
        curl -f ${{ secrets.PRODUCTION_URL }}/health
        
        # Critical business endpoints
        curl -f "${{ secrets.PRODUCTION_URL }}/api/products/search?q=whey"
        curl -f "${{ secrets.PRODUCTION_URL }}/api/retailers"
        curl -f "${{ secrets.PRODUCTION_URL }}/api/deals"
        
        # MCP server (internal)
        if curl -f ${{ secrets.PRODUCTION_URL }}/mcp/capabilities; then
          echo "âœ… MCP server accessible"
        else
          echo "âš ï¸  MCP server not accessible (expected for external checks)"
        fi
        
        echo "âœ… Production validation completed"

    - name: Performance validation
      run: |
        # Quick performance check
        RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}\n' ${{ secrets.PRODUCTION_URL }}/api/products/search?q=test)
        
        if (( $(echo "$RESPONSE_TIME > 0.5" | bc -l) )); then
          echo "âš ï¸  Response time ${RESPONSE_TIME}s exceeds 500ms target"
        else
          echo "âœ… Response time ${RESPONSE_TIME}s within target"
        fi

  # OpenTelemetry integration check
  observability-check:
    name: Observability Integration Check
    runs-on: ubuntu-latest
    needs: production-smoke-tests
    
    steps:
    - name: Verify telemetry pipeline
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USER }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          cd /opt/proteinprices
          
          # Check metrics are being collected
          curl -s http://localhost:9090/metrics | grep -q "http_requests_total" && echo "âœ… Metrics collection active" || echo "âŒ Metrics collection failed"
          
          # Check traces are being sent
          curl -s http://localhost:16686/api/services | jq -r '.data[]' | grep -q "proteinprices" && echo "âœ… Distributed tracing active" || echo "âŒ Tracing failed"
          
          # Check log aggregation
          docker-compose -f docker-compose.prod.yml logs --tail=10 api | grep -q "level=info" && echo "âœ… Structured logging active" || echo "âŒ Logging configuration issue"

  # Production deployment completion
  deployment-complete:
    name: Production Deployment Complete
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, production-smoke-tests, observability-check]
    if: always() && (needs.production-smoke-tests.result == 'success')
    
    steps:
    - name: Deployment summary
      run: |
        echo "ðŸŽ‰ Production deployment completed successfully!"
        echo ""
        echo "ðŸ“‹ Deployment Summary:"
        echo "  â€¢ SHA: ${{ needs.pre-deployment-validation.outputs.deployment_sha }}"
        echo "  â€¢ Services: ${{ needs.pre-deployment-validation.outputs.services_to_deploy }}"
        echo "  â€¢ Strategy: ${{ github.event.inputs.deployment_strategy }}"
        echo "  â€¢ Skip Migrations: ${{ github.event.inputs.skip_migrations }}"
        echo ""
        echo "âœ… All services deployed and validated"
        echo "âœ… Database migrations: ${{ github.event.inputs.skip_migrations == 'true' && 'SKIPPED' || 'COMPLETED' }}"
        echo "âœ… Smoke tests: PASSED"
        echo "âœ… Observability: ACTIVE"
        echo ""
        echo "ðŸ”— Production URL: ${{ secrets.PRODUCTION_URL }}"
        echo "ðŸ“Š Monitoring: ${{ secrets.PRODUCTION_URL }}:3000"

    - name: Update deployment record
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USER }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          # Record deployment in audit log
          echo "$(date '+%Y-%m-%d %H:%M:%S') - PRODUCTION DEPLOYMENT - SHA: ${{ needs.pre-deployment-validation.outputs.deployment_sha }} - Services: ${{ needs.pre-deployment-validation.outputs.services_to_deploy }} - Strategy: ${{ github.event.inputs.deployment_strategy }} - User: ${{ github.actor }}" >> /opt/proteinprices/logs/deployment-audit.log